## Discovering and Exploiting Caching Issues (Web Cache Poisoning)


#### ðŸŒ³ What is Web Cache Poisoning?
Web cache poisoning is a technique where an attacker injects malicious payloads into a web cache, causing that 
payload to be served to unsuspecting users. The cache is meant to optimize web traffic by storing copies of 
resources, but if improperly configured, it can become a vector for widespread exploitation.


#### ðŸŒ³ Why It Matters in Bug Bounty ?
- Affects every user that receives the poisoned cache
- Often missed by automated scanners
- Can lead to account takeover, token leakage, XSS, or redirects
- Frequently found in CDNs, reverse proxies, and load balancers

Bug bounty programs reward cache poisoning highly when it leads to user impact.


#### ðŸŒ³ Common Cache Points:-
- CDNs (Cloudflare, Akamai, Fastly)
- Web accelerators (Varnish, Squid)
- Reverse proxies (Nginx, HAProxy)
- Load balancers with caching features

Often, shared caching layers are used to serve content to all users, making successful poisoning much more impactful.


#### ðŸŒ³ Basic Testing Approach:-
- Identify cachable endpoints (static assets, pages that look like they're reused)
- Test header-based variation: Does the server cache based on unexpected headers?

Example:

    GET /home HTTP/1.1
    Host: target.com
    X-Forwarded-Host: evil.com

Check if the response reflects your injected header in any way.


#### ðŸŒ³ Poisoning via HTTP Headers
Headers to try:
- `X-Forwarded-Host`
- `X-Forwarded-For`
- `X-Host`
- `X-Original-URL`
- `Referer`
- `X-Rewrite-URL`   

If any of these are reflected in the page and stored in the cache, they may be exploitable.


#### ðŸŒ³ Key Conditions for Exploitation:- 
- The cache must store the poisoned response
- Other users must receive the cached (poisoned) response
- The poisoned content must be usable for further exploitation

This typically means the application:
- Reflects headers into the page content or response
- Doesnâ€™t validate certain headers before caching
- Serves content without strict cache-control policies


#### ðŸŒ³ Tools and Payloads:-
Tools:
- ParamMiner (Burp Suite extension) [https://portswigger.net/bappstore/9f8790436d3d4e03b2e16c099a4cf92c]
- [Cache Poisoning Scanner (custom scripts or Burp plugins)]
- `curl` for fast manual testing

Payloads to test:
- Injected JavaScript: `</script><script>alert(1)</script>`
- External URLs: `(https://evil.com/steal)`  


#### ðŸŒ³ High-Impact Scenarios:-
- Poisoned redirect to phishing site
- Injected JavaScript into homepage (stored XSS)
- Serving incorrect login tokens or user IDs
- UI redressing or login defacement
- Cache poisoning used as a pivot to stored XSS or token theft

These payloads affect users who visit the poisoned page or asset before the cache is cleared.


#### ðŸŒ³ Mitigation Techniques (What to Suggest in Reports):- 
- Avoid reflecting unvalidated headers in responses
- Use strict Cache-Control: private, no-store on dynamic pages
- Normalize and canonicalize URLs before caching
- Disable caching on user-specific or tokenized endpoints
- Configure reverse proxies and CDNs to ignore dangerous headers


#### ðŸŒ³ Final Insight:-
Web cache poisoning is not theoretical. Itâ€™s a subtle, often overlooked attack surface that requires strong 
intuition and curiosity to exploit. Successful cache poisoning requires understanding of backend infrastructure, 
careful header manipulation, and persistence in testing. It rewards those who donâ€™t stop at the first 200 OK.
