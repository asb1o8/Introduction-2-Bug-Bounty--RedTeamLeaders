## Identifying Uncommon Parameters and Hidden Fields


#### ðŸŒ³ Why These Parameters Matter?
Many web vulnerabilities stem from hidden or non-obvious parameters that were never intended to be
user-controlled. These include:
- Legacy parameters no longer visible in the UI
- Developer/debug fields
- Undocumented API keys or feature flags
- Parameters only exposed during specific workflows

These "forgotten" parameters often lack proper validation and can lead to IDORs, privilege escalation, 
forced browsing, business logic abuse, and more.


#### ðŸŒ³ Common Types of Hidden or Overlooked Inputs:-
- `is_admin` , `user_id` , `debug` , `role` , `internal` , `price` 
- Hidden fields in HTML forms `(<input type="hidden" ...>)`
- Obscure GET/POST parameters passed via JavaScript
- Fields dynamically added via JS but not shown in initial response
- Parameters used only in internal API calls or mobile endpoints


#### ðŸŒ³ Sources to Discover Uncommon Parameters:-
- JS Files: Look for hardcoded param names
- Burp Proxy: Intercept and inspect all requests, especially those triggered by JS or AJAX
- Parameter Pollution: Try duplicating parameters to observe app behavior
- Brute-force guessing: Based on naming conventions
- Mobile apps: Decompile APKs to reveal internal API calls and undocumented fields


#### ðŸŒ³ Techniques for Discovering Hidden Parameters:-
- Burp Suite â€“ Param Miner extension: Brute-forces common parameter names on endpoints
- Fuzzing: Try payloads in unexpected locations (headers, JSON bodies, GET/POST fields)
- Wordlists: Use lists like `SecLists/Discovery/Web-Content/burp-parameter-names.txt` 
- Replay old requests after modifying or injecting additional parameters


#### ðŸŒ³ Focusing on Application Context:-
Pay attention to:
- Parameters tied to roles/permissions
- Workflow-specific values (e.g., cart price, account status)
- Features that toggle behavior (e.g., &preview=true, &debug=1)
- API parameters vs Web UI (they often differ)

Apps built on frameworks like Angular or React often pass state using obscure or serialized fields.


#### ðŸŒ³ Case Studies from Real Findings:-
- A price `parameter` allowed users to lower the cost of checkout items
- An unused `is_admin=true` parameter returned privileged data
- Hidden `debug=1` output internal server paths and stack traces
- `user_id` passed via GET parameter allowed full IDOR across accounts

These are often missed in automated scans but easily found with smart manual inspection.


#### ðŸŒ³ Tips for Brute-Forcing Hidden Params:-
- Use `ffuf`, `wfuzz`, or Burp Intruder to iterate through parameter names
- Try both GET and POST requests
- Monitor response changes (status code, length, message)
Focus on endpoints with sensitive actions: `/delete`, `/update,` `/checkout`, etc.

Example using ffuf:

    ffuf -w params.txt -X POST -d 'FUZZ=value' -u https://target.com/endpoint -H "Content-Type: application/x-www-form-urlencoded"


#### ðŸŒ³ Inspecting JavaScript for Hidden Logic:-
- Grep for`fetch()`, `XMLHttpRequest`, or `.open calls`
- Look for hidden features or functions like adminMode, getUserById(), etc.
- Unminify and beautify JavaScript if obfuscated

Use tools like:
- `JSParser`
- `LinkFinder`
- `Burp JS Revealer`


#### ðŸŒ³ Understanding Context-Based Parameter Exposure:-
- Some parameters appear only after a user performs specific actions
- Others are available only to specific roles (e.g., admin users)
- Try changing user roles or navigating different flows to surface more fields

Capture multiple workflows in Burp and compare request structures.


#### ðŸŒ³ Final Insight:-
Most impactful bugs come from where the application assumes "the user will never see or touch this." 
Your job is to find and manipulate those assumptions.

Look beyond the UI. Hidden parameters often hold the keys to serious vulnerabilities.
